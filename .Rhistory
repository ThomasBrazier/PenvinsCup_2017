quadContrib$col.rel
quadContrib$row.abs
quadContrib$col.rel
seuil = 1/23*100 # seuil = 9,090909 (1/le plus petit)
# Histogrammes des contributions
hist(quadContrib$col.abs[1])
# Histogrammes des contributions
hist(quadContrib$col.abs)
quadContrib$col.abs # contributions absolues sur les espèces
quadContrib$col.abs[1] # contributions absolues sur les espèces
# Histogrammes des contributions
hist(as.numeric(quadContrib$col.abs))
class(quadContrib$col.abs)
# Histogrammes des contributions
hist(as.numeric(quadContrib$col.abs[1]))
# Histogrammes des contributions
plot(quadContrib$col.abs[1])
?plot
# Histogrammes des contributions
plot(quadContrib$col.abs[1], type = "h")
# Histogrammes des contributions
plot(sort(quadContrib$col.abs[1], type = "h"))
# Histogrammes des contributions
plot(quadContrib$col.abs[1], type = "h")
# Histogrammes des contributions
hist(quadContrib$col.abs[1], type = "h")
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$li, 1)
dendoQuad=hclust(distQuad,"ward.D2")
plot(dendoQuad, main="Dendogramme sur les populations intertidales")
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$col, 1)
dendoQuad=hclust(distQuad,"ward.D2")
plot(dendoQuad, main="Dendogramme sur les populations intertidales")
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$col, 1)
?dist.quant
summary(distQuad)
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$col, 1)
dendoQuad=hclust(distQuad,"ward.D2")
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$col, 1)
dendoQuad=hclust(distQuad,"ward.D2")
quadAFC$li
quadAFC$col
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$li, 1)
dendoQuad=hclust(distQuad,"ward.D2")
plot(dendoQuad, main="Dendogramme sur les populations intertidales")
plot(dendoQuad$height, type="s")
# On choisit de prendre 4 groupes
decoupQuad = cutree(dendoOiseaux, 4)
quadAFC$tab
quadAFC
# Réalisation de la CAH : regroupements
distQuad=dist.quant(quadAFC$co, 1)
dendoQuad=hclust(distQuad,"ward.D2")
plot(dendoQuad, main="Dendogramme sur les populations intertidales")
plot(dendoQuad$height, type="s")
# On choisit de prendre 5 groupes
decoupQuad = cutree(dendoQuad, 5)
decoupQuad # chaque site est affecté à un groupe
s.class(quadAFC$co,as.factor(decoupQuad))
# découpage + projection des lignes
s.label(quadAFC$co, clabel=0.5)
s.class(quadAFC$co, as.factor(decoupQuad),add.plot=T)
# découpage + projection des lignes
s.label(quadAFC$co, clabel=0.8)
s.class(quadAFC$co, as.factor(decoupQuad),add.plot=T)
# découpage + projection des lignes
s.label(quadAFC$co, clabel=0.8)
s.class(quadAFC$co, as.factor(decoupQuad))
# découpage + projection des lignes
s.label(quadAFC$co, clabel=0.8,add.plot = T)
quadAFC$tab
quadContrib$col.abs # contributions absolues sur les espèces
# Histogrammes des contributions
quadContrib$col.abs
# Histogrammes des contributions
hist(quadContrib$col.abs)
# Histogrammes des contributions
hist(quadContrib$col.abs[,1])
# Histogrammes des contributions
hist(quadContrib$col.abs[,1], x = rownames(quadContrib$col.abs))
rownames(quadContrib$col.abs
)
# Histogrammes des contributions
hist(y = quadContrib$col.abs[,1], x = rownames(quadContrib$col.abs))
# Histogrammes des contributions
hist(y = quadContrib$col.abs[,1])
?hist
# Histogrammes des contributions
hist(y = quadContrib$col.abs[,1], breaks = 23)
# Histogrammes des contributions
hist(y = quadContrib$col.abs[,1], breaks = 23)
# Histogrammes des contributions
hist(y = quadContrib$col.abs[,1], breaks = "23")
# Histogrammes des contributions
hist(quadContrib$col.abs[,1], breaks = 23)
# Histogrammes des contributions
hist(quadContrib$col.abs[,1], breaks = 23, xlab = rownames(quadContrib$col.abs))
?hist
# Histogrammes des contributions
hist(quadContrib$col.abs[,1], breaks = 23, labels = rownames(quadContrib$col.abs))
# Histogrammes des contributions
hist(quadContrib$col.abs[,1], breaks = 23, labels = rownames(quadContrib$col.abs), clab = 0.5)
# Histogrammes des contributions
hist(sort(quadContrib$col.abs[,1])[1:6], breaks = 6, labels = rownames(quadContrib$col.abs))
sort(quadContrib$col.abs[,1])[1:6]
sort(quadContrib$col.abs[,1])
?sort
sort(quadContrib$col.abs[,1], decreasing = T)
sort(quadContrib$col.abs[,1], decreasing = T)[1:6]
# Histogrammes des contributions
hist(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 6, labels = rownames(quadContrib$col.abs))
# Histogrammes des contributions
hist(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 5, labels = rownames(quadContrib$col.abs))
# Histogrammes des contributions
hist(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 5, labels = rownames(quadContrib$col.abs)[1:5])
# Histogrammes des contributions
hist(y=sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 5, labels = rownames(quadContrib$col.abs)[1:5])
# Histogrammes des contributions
plot(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 5, labels = rownames(quadContrib$col.abs)[1:5])
# Histogrammes des contributions
hist(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 5, labels = rownames(quadContrib$col.abs)[1:5])
# Histogrammes des contributions
barplot(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], breaks = 5, labels = rownames(quadContrib$col.abs)[1:5])
# Histogrammes des contributions
barplot(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], labels = rownames(quadContrib$col.abs)[1:5])
# Histogrammes des contributions
barplot(sort(quadContrib$col.abs[,1], decreasing = T)[1:5])
barplot(quadAFC$eig*100/sumVP,main="Histogramme des inerties en pourcentage", ylim=c(0,50), col=heat.colors(23)) # Histogramme des inerties
# Histogrammes des contributions
barplot(sort(quadContrib$col.abs[,1], decreasing = T)[1:5])
?barplot
# Histogrammes des contributions
barplot(sort(quadContrib$col.abs[,1], decreasing = T)[1:5], names.arg = rownames(quadContrib$col.abs)[1:5]) # Histogramme des 5 variables qui contribuent à l'axe 1
# colonne densité
# densité = ind.m-2
quad[35]
# colonne densité
# densité = ind.m-2
quad[,35]
# colonne densité
# densité = ind.m-2
quad[34]
# colonne densité (35)
# densité = ind.m-2 =
quad[35] = quad$Thalap/quad$surf
colnames(quad)[35] = "dens.thais"
colnames(quad)[35] = "dens.Thalap"
# colonne densité de Litlit (36)
# densité = ind.m-2 =
quad[36] = quad$Litlit/quad$surf
colnames(quad)[36] = "dens.Litlit"
summary(quad)
#-----------------------------------------------------#
# ACP
#-----------------------------------------------------#
# Analyse sur données quantitatives
# densité Thalap (35), d.chenal (6), d.mer (7), alt (8), surf (9), densité Litlit (36)
# ACP sur quad
# préparation du tableau de variables
tabACP = quad[6:9]
tabACP = cbind(tabACP, quad[35:36])
corQuad=cor(tabACP)
corQuad
?cor
corQuad=cor(tabACP, na.rm = TRUE)
corQuad
corQuad=cor(tabACP, use = "complete.obs")
corQuad
# colonne densité de Thais lapillus (35)
# densité = ind.m-2
N = 35
# colonne densité de Thais lapillus (35)
# densité = ind.m-2
N = 34
# ACP
quadACP = dudi.pca(tabACP)
#-----------------------------------------------------#
# ACP
#-----------------------------------------------------#
# Analyse sur données quantitatives
# densité Thalap (35), d.chenal (6), d.mer (7), alt (8), surf (9), densité Litlit (36)
# ACP sur quad
# préparation du tableau de variables
tabACP = quad[6:9]
tabACP = cbind(tabACP, quad[35:36])
corQuad=cor(tabACP, use = "complete.obs")
corQuad
tabACP=tabACP[,!names(tabACP)%in%c()] # pas de variables corrélées entre elles
# ACP
quadACP = dudi.pca(tabACP)
?dudi.pca
#-----------------------------------------------------#
# ACP
#-----------------------------------------------------#
# Analyse sur données quantitatives
# densité Thalap (35), d.chenal (6), d.mer (7), alt (8), surf (9), densité Litlit (36)
# ACP sur quad
# préparation du tableau de variables
tabACP = quad[6:9]
tabACP = cbind(tabACP, quad[35:36])
while (length(which(is.na(tabACP), arr.ind = TRUE)[,1]) > 0) {
tabACP = tabACP[-which(is.na(tabACP), arr.ind = TRUE)[1,1],]
}
corQuad=cor(tabACP, use = "complete.obs")
corQuad
tabACP=tabACP[,!names(tabACP)%in%c()] # pas de variables corrélées entre elles
# ACP
quadACP = dudi.pca(tabACP)
# 2 axes retenus
quadACP
# Représentation graphique
barplot(quadACP$eig*100/6, main="Histogramme des inerties en pourcentage", ylim=c(0,50), col=heat.colors(10))
s.label(quadACP$li)
s.corcircle(quadACP$co)
# Contributions
contribQuad = inertia.dudi(quadACP, col.inertia = TRUE, row.inertia = TRUE)
contribQuad
contribQuad$col.abs
seuil = 1/length(quadACP)*100 # seuil à 12.5
# Récupération matrice de distance
distACP = dist.quant(quadACP$li, 1)
distACP
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
plot(dendoACP, main="Dendogramme des groupes sur la météo")
# Récupération matrice de distance
distACP = dist.quant(quadACP$co, 1)
distACP
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
plot(dendoACP, main="Dendogramme des groupes sur la météo")
# Récupération matrice de distance
distACP = dist.quant(quadACP$li, 1)
distACP
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
plot(dendoACP, main="Dendogramme des groupes sur la météo")
plot(dendoACP$height, type = "s")
decoupACP = cutree(dendoACP, 5) # on choisit de constituer 5 groupes
s.class(quadACP$li, as.factor(decoupACP))
setwd("~/Dropbox/M1 EFCE/Cours S1/OSE/OSE 1/Multivarie")
insect <- read.table(file = "insectes.txt", header = TRUE, dec = ",")
head(insect)
summary(insect)
meteo <- read.table(file = "meteo.txt", header = TRUE, dec = ",")
head(meteo)
summary(meteo)
# ACP sur meteo
# Vérifier les corrélations
# fortement corrélé si cor > abs(0.80)
# precipit Nuit/total
# T max/soir
# Nebu moy/nuit
# on garde Tsoir,Nebu nuit, precipit nuit -> étude insectes nocturnes
corMeteo=cor(meteo)
meteo=meteo[,-c(1,10,11)]
# ACP
meteoACP = dudi.pca(meteo)
meteoACP
# Représentation graphique
barplot(meteoACP$eig*100/8, main="Histogramme des inerties en pourcentage", ylim=c(0,50), col=heat.colors(10))
s.label(meteoACP$li)
s.corcircle(meteoACP$co)
# Contributions
contribMeteo = inertia.dudi(meteoACP, col.inertia = TRUE, row.inertia = TRUE)
# ACP
meteoACP = dudi.pca(meteo)
# 2 axes retenus
meteoACP
# Représentation graphique
barplot(meteoACP$eig*100/8, main="Histogramme des inerties en pourcentage", ylim=c(0,50), col=heat.colors(10))
s.label(meteoACP$li)
s.corcircle(meteoACP$co)
# Contributions
contribMeteo = inertia.dudi(meteoACP, col.inertia = TRUE, row.inertia = TRUE)
contribMeteo
contribMeteo$col.abs
seuil = 1/8*100 # seuil à 12.5
# Récupération matrice de distance
distMeteo = dist.quant(meteoACP$li, 1)
distMeteo
# Regroupement hiérarchique
dendoMeteo = hclust(distMeteo, method = "ward.D2")
plot(dendoMeteo, main="Dendogramme des groupes sur la météo")
plot(dendoMeteo$height, type = "s")
decoupMeteo = cutree(dendoMeteo, 5) # on choisit de constituer 5 groupes
s.class(meteoACP$li, as.factor(decoupMeteo))
# Récupération matrice de distance
distACP = dist.quant(quadACP$co, 1)
distACP
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
plot(dendoACP, main="Dendogramme des groupes sur la météo")
plot(dendoACP$height, type = "s")
decoupACP = cutree(dendoACP, 3) # on choisit de constituer 5 groupes
s.class(quadACP$co, as.factor(decoupACP))
s.label(quadACP$co)
s.class(quadACP$co, as.factor(decoupACP), add.plot = T)
s.class(quadACP$co, as.factor(decoupACP))
s.label(quadACP$co, add.plot = T)
# Récupération matrice de distance
distACP = dist.quant(quadACP$li, 1)
distACP
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
plot(dendoACP, main="Dendogramme des groupes sur la météo")
plot(dendoACP$height, type = "s")
decoupACP = cutree(dendoACP, 16) # on choisit de constituer 5 groupes
s.class(quadACP$li, as.factor(decoupACP))
s.label(quadACP$li, add.plot = T)
s.class(quadACP$li, as.factor(decoupACP))
# Récupération matrice de distance
distACP = dist.quant(quadACP$co, 1)
distACP
# Regroupement hiérarchique
dendoACP = hclust(distACP, method = "ward.D2")
plot(dendoACP, main="Dendogramme des groupes sur la météo")
plot(dendoACP$height, type = "s")
decoupACP = cutree(dendoACP, 3) # on choisit de constituer 3 groupes
s.class(quadACP$co, as.factor(decoupACP))
s.label(quadACP$co, add.plot = T)
?var
# Indice de répartition
# I = var/moyenne
# < 1 repartition spatiale régulière
# = 1 aleatoire
# > agregats
I = var(quad$Thalap, na.rm = TRUE)/mean(quad$Thalap, na.rm = TRUE)
I
# Graphe fréquence des différents effectifs obtenus
hist(quad$Thalap)
# Graphe fréquence des différents effectifs obtenus
hist(quad$Thalap, breaks = 25)
# Test de la répartition
# H0 = la répartition est aléatoire, soit I non significativement différent de 1
# Or I*(n-1) suit une loi du Khi2 à n-1 ddl
n = length(quad$Thalap)
chisq.test((I*(n-1)))
?chisq.test
# Test de la répartition
# H0 = la répartition est aléatoire, soit I non significativement différent de 1
# Or I*(n-1) suit une loi du Khi2 à n-1 ddl
n = length(quad$Thalap)
X2 =I*(n-1)
?Chisquare
pchisq(c(0.025, 0.975), df = (n-1))
pchisq(c(0.025, 0.975), df = (n-1))
pchisq(c(0.975, 0.025), df = (n-1))
chisq(c(0.025, 0.975), df = (n-1))
dchisq(c(0.025, 0.975), df = (n-1))
qchisq(c(0.025, 0.975), df = (n-1))
limChisq = qchisq(c(0.025, 0.975), df = (n-1)) # quantiles selon la loi du chi2 à n-1 ddl
setwd("~/Documents/GitHub/PenvinsCup_2017")
?split
# selon le mode battu/abrité
dens.mod = split(quad$dens.Thalap, quad$mode)
View(dens.mod)
mean(dens.mod$a)
mean(dens.mod$b)
mean(dens.mod$a, na.rm = T)
mean(dens.mod$b, na.rm = T)
# test de comparaison de moyennes
# données indépendantes
# test sur la normalité des données
shapiro.test(dens.mod$a)
shapiro.test(dens.mod$b)
# test de comparaison de moyennes
# données indépendantes
# test sur la normalité des données
shapiro.test(log(dens.mod$a))
log(dens.mod$a)
?log
dens.mod$a
?shapiro.test
# test de comparaison de moyennes
# données indépendantes
# test sur la normalité des données
shapiro.test(dens.mod$a)
shapiro.test(dens.mod$b)
# H0 rejetée : pas de normalité
# donc test de Mann-Whitney
wilcox.test(dens.mod$a~dens.mod$b, paired = FALSE)
# H0 rejetée : pas de normalité
# donc test de Mann-Whitney
wilcox.test(a~b, data = dens.mod, paired = FALSE)
?wilcox.test
# H0 rejetée : pas de normalité
# donc test de Mann-Whitney
wilcox.test(a~b, data = dens.mod, paired = FALSE)
summary(dens.mod)
dens.mod
dens.mod[!is.na(dens.mod)]
summary(dens.mod)
dens.mod[-!is.na(dens.mod)]
dens.mod$a[-!is.na(dens.mod$a)]
subset(dens.mod, !is.na(NA))
dens.mod$a[-which(is.na(dens.mod$a))]
dens.mod$a[-which(is.na(dens.mod$a))]
dens.mod$b[-which(is.na(dens.mod$b))]
mean(dens.mod$a, na.rm = T)
mean(dens.mod$b, na.rm = T)
# test de comparaison de 2 moyennes
# données indépendantes
# test sur la normalité des données
shapiro.test(dens.mod$a)
shapiro.test(dens.mod$b)
# H0 rejetée : pas de normalité
# donc test de Mann-Whitney
wilcox.test(a~b, data = dens.mod, paired = FALSE)
dens.mod$a[-which(is.na(dens.mod$a))]
str(dens.mod)
dens.mod$a
is.numeric(dens.mod$a)
# uniquement si deux distributions de taille différente
wilcox.test(a[1:230]~b, data = dens.mod, paired = FALSE)
# uniquement si deux distributions de taille différente
dens.mod$a =dens.mod$a[1:230]
wilcox.test(a~b, data = dens.mod, paired = FALSE)
# H0 rejetée : pas de normalité
# donc test de Mann-Whitney
# H0 : les deux distributions sont égales
wilcox.test(dens.Thalap~mode, data = quad, paired = FALSE)
shapiro.test(quad$dens.Thalap)
# H0 rejetée : pas de normalité
# donc test de Mann-Whitney
# H0 : les deux distributions sont égales
wilcox.test(dens.Thalap~mode, data = quad, paired = FALSE)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, quad$dens.Thalap)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$d.mer, quad$dens.Thalap)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$d.mer, quad$dens.Litlit)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, quad$dens.Litlit)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, quad$dens.Thalap)
plot(quad$d.mer, quad$dens.Thalap)
plot(quad$d.chenal, quad$dens.Thalap)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, quad$dens.Thalap~mode)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, log(quad$dens.Thalap))
plot(quad$d.mer, log(quad$dens.Thalap))
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, quad$dens.Thalap)
plot(quad$d.mer, quad$dens.Thalap)
plot(quad$d.chenal, quad$dens.Thalap)
# Graph distribution des individus en fonction alt, selon le mode
plot(quad$alt, quad$Thalap)
plot(quad$d.mer, quad$Thalap)
plot(quad$d.chenal, quad$Thalap)
source("checkPenvins.R")
# Working directory
setwd("~/Documents/GitHub/PenvinsCup_2017")
source("checkPenvins.R")
# Running a serie of checkPenvins over each file
for (f in 1:length(list.files(path = "~/Documents/Github/PenvinsCup_2017/data"))) {
tmp = read.table(paste("data/",list.files(path = "~/Documents/Github/PenvinsCup_2017/data")[f], sep = ""), header = TRUE)
checkPenvins(tmp, bilan = FALSE)
readline(prompt="Press [enter] to continue")
}
ind <- read.table("data/b30indCORR2.txt", header = TRUE)
colnames(ind)
View(ind)
colnames(ind)[6] = "d-chenal"
colnames(ind)
source("checkPenvins.R")
checkPenvins(ind)
colnames(ind)[6] = "d.chenal"
colnames(ind)[17] = "s-flaq"
checkPenvins(ind)
ind <- read.table("data/b30indCORR2.txt", header = TRUE)
colnames(ind)[17] = "s-flaq"
checkPenvins(ind)
source("checkPenvins.R")
checkPenvins(ind)
ind <- read.table("data/b30indCORR2.txt", header = TRUE)
?round
source("checkPenvins.R")
checkPenvins(ind)
source("checkPenvins.R")
# Running a serie of checkPenvins over each file
for (f in 1:length(list.files(path = "~/Documents/Github/PenvinsCup_2017/data"))) {
tmp = read.table(paste("data/",list.files(path = "~/Documents/Github/PenvinsCup_2017/data")[f], sep = ""), header = TRUE)
checkPenvins(tmp, bilan = FALSE)
readline(prompt="Press [enter] to continue")
}
source("checkPenvins.R")
# Running a serie of checkPenvins over each file
for (f in 1:length(list.files(path = "~/Documents/Github/PenvinsCup_2017/data"))) {
tmp = read.table(paste("data/",list.files(path = "~/Documents/Github/PenvinsCup_2017/data")[f], sep = ""), header = TRUE)
checkPenvins(tmp, bilan = FALSE)
readline(prompt="Press [enter] to continue")
}
ind <- read.table("tests/b30indCORR2.txt", header = TRUE)
plot(quad$Litlit, quad$Thalap)
plot(quad$Litlit, quad$Thalap)
plot(quad$p.moul, quad$Thalap)
plot(quad$p.alg, quad$Thalap)
plot(quad$p.bala, quad$Thalap)
#=====================================================#
#                       MAP
#=====================================================#
ggmap(get_map(location = c(lon = -2.682917, lat = 47.490089), zoom = 17, maptype = "satellite", source = "google"))
